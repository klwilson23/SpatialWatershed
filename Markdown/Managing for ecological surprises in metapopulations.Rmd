---
title: "Managing for ecological surprises in metapopulations"
subtitle: "Supplemental materials"
author: |
 | Kyle Logan Wilson$^1$, Colin Bailey$^1$, William Atlas$^1$, and Doug Braun$^2$
 |
 | $^1$Earth to Ocean Research Group, Simon Fraser University
 | $^2$Fisheries & Oceans Canada
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  
  pdf_document:
    pandoc_args:
    - --biblio
    - Metapop_references.bib
    - --csl
    - methods-in-ecology-and-evolution.csl
    keep_tex: true
  html_document:
    pandoc_args:
    - --biblio
    - Metapop_references.bib
    - --csl
    - methods-in-ecology-and-evolution.csl
  fig_caption: yes
  fig_height: 4
  fig_width: 4
  fontsize: 12pt
  highlight: tango
  df_print: kable
header-includes:
  - \usepackage{wrapfig}
  - \usepackage{lipsum}
  - \usepackage{float}
---

```{r setup, include=FALSE}
library(knitr)
library(knitcitations)
opts_chunk$set(echo=TRUE)
opts_chunk$set(tidy=TRUE)
opts_chunk$set(fig.show = "hold", collapse=TRUE)
#knitr::opts_chunk$set(fig.pos = 'H')
#library(devtools)
#install.packages("knitcitations")
cleanbib()
options("citation_format" = "pandoc")

defOut <- knitr::knit_hooks$get("plot")  # save the default plot hook 
knitr::knit_hooks$set(plot = function(x, options) {  # set new plot hook ...
  x <- defOut(x, options)  # first apply the default hook
  if(!is.null(options$wrapfigure)) {  # then, if option wrapfigure is given ...
    # create the new opening string for the wrapfigure environment ...
    wf <- sprintf("\\begin{wrapfigure}{%s}{%g\\textwidth}", options$wrapfigure[[1]], options$wrapfigure[[2]])
    x  <- gsub("\\begin{figure}", wf, x, fixed = T)  # and replace the default one with it.
    x  <- gsub("{figure}", "{wrapfigure}", x, fixed = T)  # also replace the environment ending
  }
  return(x)
})


knitr::opts_chunk$set(fig.pos = 'H')

library(mvtnorm)
library(marima)
library(diagram)

source("make networks.R")
source("Dispersal function.R")
source("patch_variance.R")
source("local disturbance.R")
source("some functions.R")
source("popDynFn.R")
```

## Metapopulation model
### Local & metapopulation dynamics
Our metapopulation is defined by a set of local populations $N_p$ with time-dynamics that follows birth (i.e., recruitment *R*), immigration, death, and emigration (BIDE) processes:

$N_{it}= R_{it}\epsilon_{it}+I_{it}-D_{it}-E_{it}$

where $N_{it+1}$ is the number of adults in patch *i* at time *t*, $R_{it}$ is number of recruits, $I_{it}$ is number of recruits immigrating into patch *i* from any other patch, $D_{it}$ is number of recruits that die due to disturbance regime, $E_{it}$ is the number of recruits emigrating from patch *i* into any other patch, and $\epsilon_{it}$ is stochasticity in recruitment.

Resoure monitoring often occurs at the scale of the metapopulation, hence we define metapopulation adults as:

${MN}_t = \sum_{i=1}^{N_p} N_{it}$

with metapopulation recruits:

$MR_t = \sum_{i=1}^{N_p} R_{it}$

Local patch recruitment at time *t* depended on adult densities at *t-1* and followed a reparameterized Beverton-Holt function:

$R_{it}=\cfrac{\alpha_iN_{it-1}}{1+\cfrac{\alpha_i-1}{\beta_i}N_{it-1}}$

where $\alpha_i$ is the recruitment compensation ratio and $\beta_i$ is local patch carrying capacity.

For example, in a two patch model that varies $\alpha_i$ and $\beta_i$ parameters such that

```{r recruitment}
alpha <- c(2,4)
beta <- c(100,200)
```

Management often monitors metapopulation resources as the aggregate of all local populations. In this way, recruitment compensation from local patches $\alpha_i$ gets averaged across the metapopulation leading mean compensation $\bar{\alpha}$ of `r mean(alpha)`. Likewise, the total carrying capacity of the metapopulation $\bar{\beta}$ becomes the summation of local patch carrying capacities $\beta_i$, which is `r sum(beta)`. This scale of monitoring generates the following local patch and metapopulation dynamics:

```{r recruit curves, echo=FALSE,warning = F, message = F,fig.width=7, fig.height = 6,fig.cap="Metapopulation and local patch recruitment dynamics.",out.width = ".7\\textwidth", fig.align="right", wrapfigure = list("R", .7)}
curve((alpha[1]*x)/(1+((alpha[1]-1)/beta[1])*x),from=0,to=beta[1],lwd=2,col="orange",xlab="Adults (t-1)",ylab="Recruits (t)",ylim=c(0,sum(beta)),xlim=c(0,sum(beta)))
curve((alpha[2]*x)/(1+((alpha[2]-1)/beta[2])*x),from=0,to=beta[2],lwd=2,col="dodgerblue",add=TRUE)
curve((mean(alpha)*x)/(1+((mean(alpha)-1)/sum(beta))*x),from=0,to=sum(beta),lwd=2,col="black",add=TRUE)
legend("bottomright",c("Patch 1","Patch 2","Metapopulation"),bty="n",lwd=2,col=c("orange","dodgerblue","black"))

```

### Creating the spatial networks

The next aspect to our metapopulation model is connecting the set of patches to one another. We need to specify the number of patches, their arrangements (i.e., connections), and how far apart they are from one another. We followed some classic metapopulation and source-sink arrangements to create four networks that generalize across a few real-world topologies: a linear habitat network (e.g., coastline), a dendritic or branching network (e.g., coastal rivers), a star network (e.g., mountain & valley), and a complex network (e.g., terrestrial plants). 

To make networks comparable, each spatial network type needs the same leading parameters (e.g., $N_p$ and $\bar{d}$) . In this case for number of patches, we set $N_p$ to `16` and $\bar{d}$ to `1` unit (distance units are arbitrary). We used the `igraph` package and some custom code to arrange our spatial networks as the following:

```{r networks, echo=FALSE,fig.hold=TRUE,fig.cap="Four spatial network topologies."}

source("some functions.R")
source("make networks.R")
patchDist <- 1
Npatches <- 16
layout(matrix(1:4,nrow=2,ncol=2,byrow=T))
par(mar=c(1,1,1,1),oma=c(0,0,0,0))

nodeScalar <- 16
network <- makeNetworks("linear",Npatches=Npatches,patchDist=patchDist)
plot(network$landscape,col="dodgerblue",layout=cbind(0,seq(1,-1,length.out = gorder(network$landscape))),vertex.size=network$node.size*nodeScalar,xlim=c(-1,1),ylim=c(-1,1),rescale=FALSE)
title(main="Linear",line=0,font.main=1)

nodeScalar <- 18
network <- makeNetworks("dendritic",Npatches=Npatches,patchDist=patchDist)
plot(network$landscape,col="dodgerblue",layout=layout_as_tree(network$landscape,root=V(network$landscape)[1]),vertex.size=network$node.size*nodeScalar)
title(main="Dendritic",line=0,font.main=1)

network <- makeNetworks("star",Npatches=Npatches,patchDist=patchDist)
plot(network$landscape,col="dodgerblue",layout=layout.reingold.tilford(network$landscape,circular=T),vertex.size=network$node.size*nodeScalar)
title(main="Star",line=0,font.main=1)

network <- makeNetworks("complex",Npatches=Npatches,patchDist=patchDist)
spatialLayout <- matrix(MORELETTERS(1:Npatches),nrow=sqrt(Npatches),ncol=sqrt(Npatches),byrow=TRUE)
spatialLayout <- t(sapply(1:Npatches,function(x){which(spatialLayout==LETTERS[x],arr.ind=TRUE)}))
spatialLayout <- spatialLayout[rank(attr(V(network$landscape),"names")),]
plot(network$landscape,col="dodgerblue",layout=spatialLayout,vertex.size=network$node.size*nodeScalar)
title(main="Complex",line=0,font.main=1)

```

Note that distances between each connecting patch (the links between nodes) in the above networks are equal.

An example dispersal matrix for the complex network: 
```{r distance matrix,echo=FALSE}
print(network$distanceMatrix)
```


### Dispersal

Dispersal from patch *i* into patch *j* depends on constant dispersal rate $\omega$ (defined as the proportion of total local recruits that will disperse) and an exponential distance-decay function between *i* and *j* with distance cost to dispersal $m$ following:

$E_{ij(t)}=\omega R_{it}p_{ij}$

with probability of dispersal from patch i into patch j:

$p_{ij}=\dfrac{e^{-md_{ij}}}{\sum\limits_{\substack{j=1 \\ j\neq i}}^{N_p} e^{-md_{ij}}}$

where $d_{ij}$ is the pairwise distance between patches and $E_{ij}$ is the total dispersing animals from patch i into patch j. The summation term in the denominator normalizes the probability of moving to any patch to between 0 and 1. With $\bar{d}= 1$, $m=0.5$, $\omega=0.1$, $R_{it}=100$ in a linear network:

```{r dispersal,echo=FALSE,fig.hold=TRUE,fig.cap="Example dispersal patterns across linear network."}
patchDist <- 1
Npatches <- 16
m <- 0.5
omega <- 0.10
network <- makeNetworks("linear",Npatches=Npatches,patchDist=patchDist)
N <- 100
E <- dispersal(omega,m,network$distanceMatrix,N)

layOut <- matrix(1,nrow=8,ncol=12,byrow=T)
layOut[-8,5:11] <- 2
layout(layOut)
par(mar=c(5,4,0,0))
plot(network$distanceMatrix[,"A"],E$dispersers[,"A"],xlab="Distance from patch i to j",ylab="Number of dispersers",lwd=2,type="l",cex.lab=1.5)
par(mar=c(1,1,1,1))
nodeScalar <- 14
plot(network$landscape,col="dodgerblue",layout=cbind(1,seq(1,-1,length.out = gorder(network$landscape))),vertex.size=network$node.size*nodeScalar,xlim=c(-1,1),ylim=c(-1,1),rescale=FALSE)
```

### Recruitment stochasticity

### Disturbance

## Emergent outcomes

### Scale of management & monitoring

## Example scenarios

##