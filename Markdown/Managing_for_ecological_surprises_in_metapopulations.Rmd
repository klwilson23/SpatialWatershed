---
title: "Managing emergent recovery dynamics in at-risk metapopulations"
author: |
  | Kyle L. Wilson$^\textup{1,2}$^[Corresponding author - email: klwilson.ccira@gmail.com], Alexandra C. Sawyer$^\textup{1}$, Anna Potapova$^\textup{1}$, Colin J. Bailey$^\textup{1}$,Daniella LoScerbo$^\textup{3,4}$,
  | Elissa K. Sweeney-Bergen$^\textup{1,5}$, Emma E. Hodgson$^\textup{1,4}$, Kara J. Pitman$^\textup{1}$, Karl M. Seitz$^\textup{1}$,
  | Lauren Law$^\textup{1,6}$, Luke Warkentin$^\textup{1,7}$, Samantha M. Wilson$^\textup{1}$, William I. Atlas$^\textup{1,8}$, 
  | Douglas C. Braun$^\textup{3,5}$, Matthew R. Sloat$^\textup{8}$, M. Tim Tinker$^\textup{9}$, 
  | and Jonathan W. Moore$^\textup{1,3}$
  |
  | $^\textup{1}$Earth to Ocean Research Group, Simon Fraser University
  | $^\textup{2}$Central Coast Indigenous Resource Alliance, Campbell River, BC
  | $^\textup{3}$Resource and Environmental Management, Simon Fraser University
  | $^\textup{4}$Fisheries & Oceans Canada, Cultus Lake Laboratory, Cultus Lake, BC
  | $^\textup{5}$Ministry of Forests, Lands, Natural Resource Operations, and Rural Development, Smithers, BC
  | $^\textup{6}$Fisheries & Oceans Canada, Salmonid Enhancement Program, Nanaimo, BC
  | $^\textup{7}$Fisheries & Oceans Canada, North Coast Stock Assessment, Smithers, BC
  | $^\textup{8}$Wild Salmon Center, Portland, OR
  | $^\textup{9}$Ecology and Evolutionary Biology, University of California Santa Cruz
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  pdf_document:
    keep_tex: yes
    latex_engine: xelatex
  highlight: tango
  html_document:
  word_document: default
  df_print: kable
  toc: true
  fontsize: 11pt
  fig_caption: yes
subtitle: 'Supplemental materials: Model details & results'
bibliography: Metapop_references.bib
csl: conservation-letters.csl
geometry: margin=0.75in
filters:
  - type: bib
    path: "Markdown/Metapop_references.bib"
  - type: pandoc-citeproc
header-includes:
- \usepackage{setspace}
- \singlespacing
- \usepackage{wrapfig}
- \usepackage{lipsum}
- \usepackage{float}
- \usepackage{lineno}
- \usepackage{amsmath}
- \linenumbers
- \renewcommand{\thefigure}{S\arabic{figure}}
- \renewcommand{\thetable}{S\arabic{table}}
- \renewcommand{\theequation}{S.\arabic{equation}}
- \usepackage{fancyhdr}
- \setlength{\parskip}{\baselineskip}
- \usepackage{tocloft}
- \setlength{\cftbeforesecskip}{6pt}
---

```{r setup, include=FALSE}
library(distill)
library(formatR)
library(knitr)
#library(bibtex)
library(knitcitations)
opts_chunk$set(echo=TRUE)
opts_chunk$set(tidy=TRUE)
opts_chunk$set(fig.show = "hold", collapse=TRUE)
knitr::opts_chunk$set(fig.pos = 'H')
#library(devtools)
#install_github(repo="cboettig/knitcitations")
cleanbib()
options("citation_format" = "pandoc")
#biblio <- read.bibtex(file = "Metapop_references.bib")
defOut <- knitr::knit_hooks$get("plot")  # save the default plot hook 
knitr::knit_hooks$set(plot = function(x, options) {  # set new plot hook ...
  x <- defOut(x, options)  # first apply the default hook
  if(!is.null(options$wrapfigure)) {  # then, if option wrapfigure is given ...
    # create the new opening string for the wrapfigure environment ...
    wf <- sprintf("\\begin{wrapfigure}{%s}{%g\\textwidth}", options$wrapfigure[[1]], options$wrapfigure[[2]])
    x  <- gsub("\\begin{figure}", wf, x, fixed = T)  # and replace the default one with it.
    x  <- gsub("{figure}", "{wrapfigure}", x, fixed = T)  # also replace the environment ending
  }
  return(x)
})

knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
```

```{r source,echo=FALSE,warning = FALSE, message = FALSE}
library(mvtnorm)
library(marima)
library(diagram)
library(vioplot)
library(ggplot2)

source("Functions/make networks.R")
source("Functions/Dispersal function.R")
source("Functions/patch_variance.R")
source("Functions/local disturbance.R")
source("Functions/some functions.R")
source("Functions/popDynFn.R")
source("Functions/Metapop function.R")
source("Functions/finding MSY.R")
```

\centering
\raggedright
\renewcommand{\baselinestretch}{1}\normalsize
\tableofcontents
\renewcommand{\baselinestretch}{0.75}\normalsize
\newpage

\pagestyle{fancy}
\fancyhead[LO,LE]{Wilson \textit{et al.}}
\fancyhead[RO,RE]{\textbf{Appendix A}: Managing ecological surprises}

## Metapopulation model
### Local & metapopulation dynamics
Our metapopulation was defined by a set of $P$ local populations for a species with a one year generation time with time-dynamics that follows birth (i.e., recruitment *R*), immigration, death, and emigration processes typical to metapopulation theory and tested the role of multiple spatial, temporal, and density-dependent processes [@Anderson2015; @Okamoto2020]:

\begin{align}
N_{i,t}= R_{i,t}+{\sum\limits_{\substack{j=1 \\ j\neq i}}^{P} \omega p_{i,j}R_{j,t}}-d_{i,t}R_{i,t}-\omega R_{i,t}
\end{align}

where $N_{i,t}$ was the number of adults in patch *i* at time *t*, $R_{i,t}$ was the number of recruits at time *t*, ${\sum\limits_{\substack{j=1 \\ j\neq i}}^{P} \omega p_{i,j}R_{j,t}}$ was the number of recruits immigrating into patch *i* from any other patch, $\omega$ was the proportion of local recruits to disperse, $p_{i,j}$ was a distance-dependent dispersal function, and $d_{i,t}$ was the proportion of recruits that die due to disturbance regime.

Local patch recruitment at time *t* depended on adult densities at *t-1* and followed a reparameterized Beverton-Holt function [@Walters2004;@Forrest2010]:

\begin{align}
R_{i,t}=\cfrac{\alpha_iN_{i,t-1}}{1+\cfrac{\alpha_i-1}{\beta_i}N_{i,t-1}}\epsilon_{i,t}
\end{align}

where $\alpha_i$ was the recruitment compensation ratio, $\beta_i$ was local patch carrying capacity, and $\epsilon_{i,t}$ was lognormally distributed deviates to introduce stochastic recruitment dynamics.

Resource monitoring often occurs at the scale of the whole metapopulation by aggregating abundances among local populations to [@Anderson2015;@Moore2021], hence we define metapopulation adults as:

\begin{align}
{A}_t = \sum_{i=1}^{P} N_{i,t}
\end{align}

with metapopulation recruits:

\begin{align}
K_t = \sum_{i=1}^{P} R_{i,t}
\end{align}

Monitoring at the scale of the whole metapopulation can produce productivity relationships that aggregates the population dynamics and productivity among all local populations. For example, take a two patch metapopulation model that varies $\alpha_i$ and $\beta_i$ parameters where:
```{r recruitment}
alpha <- c(2,4)
beta <- c(100,200)
```
Here, recruitment compensation from local patches $\alpha_i$ gets averaged across the metapopulation leading to an average compensation ratio $\bar{\alpha}$ of `r mean(alpha)`. Likewise, the total carrying capacity of the metapopulation $\bar{\beta}$ becomes the summation of local patch carrying capacities $\sum\beta_i$, which was `r sum(beta)`. This scale of monitoring generates the following local patch and metapopulation dynamics:

<br>
```{r recruit curves, echo=FALSE,warning = F, message = F,fig.hold=TRUE,fig.width=4.5, fig.height = 4,fig.cap="Metapopulation and local patch recruitment dynamics.",fig.align="center"}

curve((alpha[1]*x)/(1+((alpha[1]-1)/beta[1])*x),from=0,to=1.5*beta[1],lwd=2,col="orange",xlab="Adults (t-1)",ylab="Recruits (t)",ylim=1.5*c(0,sum(beta)),xlim=1.5*c(0,sum(beta)))
curve((alpha[2]*x)/(1+((alpha[2]-1)/beta[2])*x),from=0,to=1.5*beta[2],lwd=2,col="dodgerblue",add=TRUE)
curve((mean(alpha)*x)/(1+((mean(alpha)-1)/sum(beta))*x),from=0,to=1.5*sum(beta),lwd=2,col="black",add=TRUE)
abline(b=1,a=0,lty=2,lwd=2,col="grey50")
legend("bottomright",c("Patch 1","Patch 2","Metapopulation","Replacement"),bty="n",lwd=2,lty=c(1,1,1,2),col=c("orange","dodgerblue","black","grey50"))

```
<br>

### Creating the spatial networks
The next aspect to our metapopulation model was connecting the set of patches to one another [@Yeakel2014]. We need to specify the number of patches, their arrangements (i.e., connections), and how far apart they are from one another. We followed some classic metapopulation and source-sink arrangements to create four networks that generalize across a few real-world topologies: a linear habitat network (e.g., coastline), a dendritic or branching network (e.g., coastal rivers), a star network (e.g., mountain & valley, or lake with inlet tributaries), and a grid network (e.g., grasslands). 
  
To make networks comparable, each spatial network type needs the same leading parameters (e.g., number of patches $P$ and mean distance between neighboring patches $\bar{d}$). In this case, we set $P$ to `16` and $\bar{d}$ to `1` unit (distance units are arbitrary). We used the `igraph` package [@Csardi2006] and some custom code to arrange our spatial networks as the following:

<br>
```{r networks, echo=FALSE,fig.hold=TRUE,fig.width=5, fig.height = 5,fig.cap="Four spatial network topologies.",fig.align="center"}
source("Functions/some functions.R")
source("Functions/make networks.R")
patchDist <- 1
Npatches <- 16
layout(matrix(1:4,nrow=2,ncol=2,byrow=T))
par(mar=c(1,1,1,1),oma=c(0,0,0,0))

nodeScalar <- 16
network <- makeNetworks("linear",Npatches=Npatches,patchDist=patchDist,colors="grey70")
plot(network$landscape,col="dodgerblue",layout=cbind(0,seq(1,-1,length.out = gorder(network$landscape))),vertex.size=network$node.size*nodeScalar,xlim=c(-1,1),ylim=c(-1,1),rescale=FALSE)
title(main="Linear",line=0,font.main=1)

nodeScalar <- 18
network <- makeNetworks("dendritic",Npatches=Npatches,patchDist=patchDist,colors="grey70")
plot(network$landscape,col="dodgerblue",layout=layout_as_tree(network$landscape,root=V(network$landscape)[1]),vertex.size=network$node.size*nodeScalar)
title(main="Dendritic",line=0,font.main=1)

network <- makeNetworks("star",Npatches=Npatches,patchDist=patchDist,colors="grey70")
plot(network$landscape,col="dodgerblue",layout=layout.reingold.tilford(network$landscape,circular=T),vertex.size=network$node.size*nodeScalar)
title(main="Star",line=0,font.main=1)

network <- makeNetworks("complex",Npatches=Npatches,patchDist=patchDist,colors="grey70")
spatialLayout <- matrix(MORELETTERS(1:Npatches),nrow=sqrt(Npatches),ncol=sqrt(Npatches),byrow=TRUE)
spatialLayout <- t(sapply(1:Npatches,function(x){which(spatialLayout==LETTERS[x],arr.ind=TRUE)}))
spatialLayout <- spatialLayout[rank(attr(V(network$landscape),"names")),]
plot(network$landscape,col="dodgerblue",layout=spatialLayout,vertex.size=network$node.size*nodeScalar)
title(main="Grid",line=0,font.main=1)

```
<br>

Note that distances between neighbor patches in the above networks are equal.

\newpage

An example dispersal matrix for the grid network: 
```{r distance matrix,echo=FALSE}
print(network$distanceMatrix)
```

### Dispersal

Dispersal from patch *i* into patch *j* depends on constant dispersal rate $\omega$ (defined as the proportion of total local recruits that will disperse) and an exponential distance-decay function between *i* and *j* with distance cost to dispersal $m$ following @Anderson2015:

\begin{align}
E_{i,j,t}=\omega R_{i,t}p_{i,j}
\end{align}

where $E_{i,j}$ was the total dispersing animals from patch *i* into patch *j* resulting from dispersal rate $\omega$, total number of local recruits $R_{i,t}$, and probability of dispersal between patches $p_{i,j}$:

\begin{align}
p_{i,j}=\dfrac{e^{-md_{i,j}}}{\sum\limits_{\substack{j=1 \\ j\neq i}}^{P} e^{-md_{i,j}}}
\end{align}

where $d_{i,j}$ was the pairwise distance between patches, $m$ was the distance cost to dispersal. The summation term in the denominator normalizes the probability of moving to any patch to between 0 and 1 with the constraint that dispersers cannot move back into their home patch (i.e., $j\neq i$. With $\bar{d}= 1$, $m=0.5$, $\omega=0.1$, $R_{i,t}=100$ in a linear network):

<br>

```{r dispersal,echo=FALSE,fig.hold=TRUE,fig.height=3.5,fig.width=4,fig.cap="Example dispersal patterns across linear network.",fig.align="center"}
patchDist <- 1
Npatches <- 16
m <- 0.5
omega <- 0.10
network <- makeNetworks("linear",Npatches=Npatches,patchDist=patchDist,colors="grey70")
N <- 100
E <- dispersal(omega,m,network$distanceMatrix,N)

layOut <- matrix(1,nrow=8,ncol=12,byrow=T)
layOut[-8,5:11] <- 2
layout(layOut)
par(mar=c(5,4,0,0))
plot(network$distanceMatrix[,"A"],E$dispersers[,"A"],xlab="Distance from patch i to j",ylab="Number of dispersers",lwd=2,type="l",cex.lab=1.5)
par(mar=c(1,1,1,1))
nodeScalar <- 14
plot(network$landscape,col="dodgerblue",layout=cbind(1,seq(1,-1,length.out = gorder(network$landscape))),vertex.size=network$node.size*nodeScalar,xlim=c(-1,1),ylim=c(-1,1),rescale=FALSE)

```
<br>

### Disturbance regimes

In all scenarios, disturbance was applied after `50` years of equilibrating the metapopulation at pristine conditions. We then applied the disturbance regime at year `50` (the regime varied from *uniform*, *localized, even*, and *localized, uneven* - see *Scenarios* below). Disturbance immediately removed a fixed proportion of the metapopulation adults at that time (i.e., `0.9` of $A_{t=50}$). Once applied, the metapopulation was no longer disturbed and spatio-temporal recovery dynamics emerged from these conditions given the ecological scenarios of network complexity, dispersal rate, spatio-temporal correlations, local patch demographies, and magnitude of stochastic variance.

```{r example disturbance regime, echo=FALSE,warning=FALSE,message=FALSE,fig.height=4,fig.width=8,fig.cap="Recovery regime of metapopulation with linear topology through time (a) and space (b).",fig.align="center"}
seed <- 535
set.seed(seed)
source("Functions/Linear network.R")
source("Functions/Dispersal function.R")
source("Functions/patch_variance.R")
source("Functions/local disturbance.R")
source("Functions/some functions.R")
source("Functions/Metapop function.R")
source("Functions/popDynFn.R")
source("Functions/Add landscapes plot.R")
Nyears <- 150
Nburnin <- 50
metaK <- 1600
matLayout <- matrix(0,ncol=18,nrow=12,byrow=T)
matLayout[1:12,1:9] <- 1
matLayout[1:4,10:12] <- 2
matLayout[1:4,13:15] <- 3
matLayout[5:8,10:12] <- 4
matLayout[5:8,13:15] <- 5
matLayout[9:12,10:12] <- 6
matLayout[9:12,13:15] <- 7
matLayout[4:9,16:17] <- 8
layout(matLayout)
linearSim <- metaPop(Npatches=16,networkType="linear",patchDistance=1,Nburnin=50,NyrsPost=100,omega=0.01,m=100,alpha=2,metaK=1600,cv=1e-6,DistScenario="uniform",magnitude_of_decline=0.9,lagTime=1,prodType="Beverton-Holt",rho.time=1e-5,rho.dist=1e5,compensationLag=25,dataWeighting=0.1,alphaVariable=FALSE,kVariable=FALSE,spatialPlots=FALSE)
spatialRecoveryPlotv2(textSize=1,linearSim$popDyn,linearSim$MetaPop,linearSim$k_p,Nlevels=10,linearSim$recovery,Nburnin,Nyears,nodeScalar=35,linearSim$network,networkType="linear",Npatches=Npatches,panel_text=c("(a)","(b)"),year_seq=(Nburnin+seq(0,15,by=3)))
Nlevels <- 10
textSize <- 1
par(mar=c(1,1,1,1))
plot(NA,xlim=c(-1,1),ylim=c(-1,1),xaxt="n",yaxt="n",xlab="",ylab="",frame.plot=FALSE,xpd=NA)
colorlegend(rev(colfunc(Nlevels)),zlevels=Nlevels,zlim=c(0,1),dz=0.1,posx=c(0.35,0.5),posy=c(0.1,0.95),digit=2)
title(main=expression('N'[t]*'/K'),line=0.5,font.main=1,cex.main=1.5*textSize,xpd=NA)

```

### Recruitment stochasticity
Our model allowed for stochastic recruitment that followed a lognormal distribution with average variation in recruitment of $\sigma_R$. In cases with stochastic recruitment, the deterministic recruitment in eq. S.4 becomes:

\begin{align}
R_{i,t}=\cfrac{\alpha_iN_{i,t-1}}{1+\cfrac{\alpha_i-1}{\beta_i}N_{i,t-1}}e^{(\epsilon_{i,t}-\cfrac{\sigma_{R}^2}{2})}
\end{align}

where lognormal deviates for each patch *i* at time *t* were drawn from a multivariate normal distribution (*MVN*) with bias correction $\cfrac{\sigma_{R}^2}{2}$. If $\sigma_R$ was low, then metapopulation dynamics approach the deterministic case. In some scenarios, we evaluated the role of spatially and/or temporally correlated deviates among local patches to model potential common drivers affecting metapopulation dynamics (e.g., Moran effects). Expected recruitment deviates followed a first-order autoregression model such that:

\begin{align}
\epsilon_{i,t}=\rho_T\epsilon_{t-1}+MVN(\mu=0,\Sigma=\sigma_R^2(1-\rho_T^2)e^{(-\rho_SD_{i,j})})
\end{align}


where $\rho_T$ was temporal correlation (bounded $0-1$) $\rho_S$ was rate of distance-decay in spatial correlation (bounded $0-\infty$ with higher values leading to independent patches). If $\rho_T$ was 0 and $\rho_S$ was high, then annual recruitment deviates were independent. We modelled the initial conditions for autoregressive recruitment deviates $\epsilon_{i,1}$ by drawing from a stationary normal distribution with mean $\mu=0$ and variance $\sigma_R^2$ such that:
\begin{align}
\epsilon_{i,1} \sim N(\mu=0,\sigma=\sigma_R)
\end{align}
We illustrate the effects of four kinds of recruitment deviates below using the same random number generator seed:

```{r independent stochasticity, echo=FALSE,warning=FALSE,message=FALSE,fig.height=6,fig.width=7,fig.cap="Metapopulation dynamics with independent (a), spatially correlated (b), temporally correlated (c), and spatio-temporally correlated (d) recruitment deviates. Black line indicates metapopulation, and dashed lines indicate local patches with red and blue relating to abundances after 100 years post-disturbance were less than or greater than 1.0 pre-disturbance, respectively.",fig.align="center"}
seed <- 535
set.seed(seed)
trial <- metaPop(Npatches=16,networkType="complex",patchDistance=1,Nburnin=50,NyrsPost=100,omega=0.01,m=100,alpha=2,metaK=1600,cv=0.12,DistScenario="uniform",magnitude_of_decline=0.9,lagTime=1,prodType="Beverton-Holt",rho.time=1e-5,rho.dist=1e5,compensationLag=25,dataWeighting=0.1,alphaVariable=TRUE,kVariable=TRUE,spatialPlots=FALSE)
layout(matrix(1:4,nrow=2,ncol=2,byrow=TRUE))
par(mar=c(5,4,1,1))
textSize <- 1
Nyears <- 150
Nlevels <- 10
popDyn <- trial$popDyn
k_p <- trial$k_p
MetaPop <- trial$MetaPop
metaK <- 1600
recovery <- trial$recovery
Nburnin <- 50
levelFactors <- factor(pmax(0.0,pmin(1.0,round(popDyn[Nyears,,"Spawners"]/k_p*Nlevels)/Nlevels)),levels=((0:10)/Nlevels))
colfunc <- colorRampPalette(c("royalblue4","dodgerblue","lightblue","darkorange1","firebrick"))
matplot(t(t(popDyn[,,"Spawners"])/k_p),type="l",xlab="Time",ylab="Relative abundance (N/K)",col=rev(colfunc(Nlevels+1))[levelFactors],ylim=c(0,2.1),cex.lab=textSize,xpd=TRUE)
lines(MetaPop[,"Spawners"]/metaK,lwd=3,col="black")
Corner_text("a) - independent","topleft")

set.seed(seed)
trial <- metaPop(Npatches=16,networkType="complex",patchDistance=1,Nburnin=50,NyrsPost=100,omega=0.01,m=100,alpha=2,metaK=1600,cv=0.12,DistScenario="uniform",magnitude_of_decline=0.9,lagTime=1,prodType="Beverton-Holt",rho.time=1e-5,rho.dist=0.5,compensationLag=25,dataWeighting=0.1,alphaVariable=TRUE,kVariable=TRUE,spatialPlots=FALSE)
popDyn <- trial$popDyn
k_p <- trial$k_p
MetaPop <- trial$MetaPop
recovery <- trial$recovery
levelFactors <- factor(pmax(0.0,pmin(1.0,round(popDyn[Nyears,,"Spawners"]/k_p*Nlevels)/Nlevels)),levels=((0:10)/Nlevels))
colfunc <- colorRampPalette(c("royalblue4","dodgerblue","lightblue","darkorange1","firebrick"))
matplot(t(t(popDyn[,,"Spawners"])/k_p),type="l",xlab="Time",ylab="Relative abundance (N/K)",col=rev(colfunc(Nlevels+1))[levelFactors],ylim=c(0,2.1),cex.lab=textSize,xpd=TRUE)
lines(MetaPop[,"Spawners"]/metaK,lwd=3,col="black")
Corner_text("b) - spatial","topleft")

set.seed(seed)
trial <- metaPop(Npatches=16,networkType="complex",patchDistance=1,Nburnin=50,NyrsPost=100,omega=0.01,m=100,alpha=2,metaK=1600,cv=0.12,DistScenario="uniform",magnitude_of_decline=0.9,lagTime=1,prodType="Beverton-Holt",rho.time=0.75,rho.dist=1e5,compensationLag=25,dataWeighting=0.1,alphaVariable=TRUE,kVariable=TRUE,spatialPlots=FALSE)
popDyn <- trial$popDyn
k_p <- trial$k_p
MetaPop <- trial$MetaPop
recovery <- trial$recovery
levelFactors <- factor(pmax(0.0,pmin(1.0,round(popDyn[Nyears,,"Spawners"]/k_p*Nlevels)/Nlevels)),levels=((0:10)/Nlevels))
colfunc <- colorRampPalette(c("royalblue4","dodgerblue","lightblue","darkorange1","firebrick"))
matplot(t(t(popDyn[,,"Spawners"])/k_p),type="l",xlab="Time",ylab="Relative abundance (N/K)",col=rev(colfunc(Nlevels+1))[levelFactors],ylim=c(0,2.1),cex.lab=textSize,xpd=TRUE)
lines(MetaPop[,"Spawners"]/metaK,lwd=3,col="black")
Corner_text("c) - temporal","topleft")

set.seed(seed)
trial <- metaPop(Npatches=16,networkType="complex",patchDistance=1,Nburnin=50,NyrsPost=100,omega=0.01,m=100,alpha=2,metaK=1600,cv=0.12,DistScenario="uniform",magnitude_of_decline=0.9,lagTime=1,prodType="Beverton-Holt",rho.time=0.75,rho.dist=0.5,compensationLag=25,dataWeighting=0.1,alphaVariable=TRUE,kVariable=TRUE,spatialPlots=FALSE)
popDyn <- trial$popDyn
k_p <- trial$k_p
MetaPop <- trial$MetaPop
recovery <- trial$recovery
levelFactors <- factor(pmax(0.0,pmin(1.0,round(popDyn[Nyears,,"Spawners"]/k_p*Nlevels)/Nlevels)),levels=((0:10)/Nlevels))
colfunc <- colorRampPalette(c("royalblue4","dodgerblue","lightblue","darkorange1","firebrick"))
matplot(t(t(popDyn[,,"Spawners"])/k_p),type="l",xlab="Time",ylab="Relative abundance (N/K)",col=rev(colfunc(Nlevels+1))[levelFactors],ylim=c(0,2.1),cex.lab=textSize,xpd=TRUE)
lines(MetaPop[,"Spawners"]/metaK,lwd=3,col="black")
Corner_text("d) - spatial-temporal","topleft")

```

## Post-disturbance outcomes
We measured the following post-disturbance outcomes to track the temporal and spatial recovery regime of the metapopulation.

1. Non-recovery (a) & recovery rate (b) after disturbance:
    a. Non-recovery rate was defined as the % of simulations where metapopulation abundance failed to recover to `1.0` of the average pre-disturbance abundance for `5` consecutive years post-disturbance. This "non-recovery rate" reflects the risk of a long-term state shift in metapopulation dynamics after disturbance in the face of stochasticity. 
    b. Recovery rate represents the proportional post-disturbance recovery towards metapopulation carrying capacity gained per year (1 year = 1 generation in our models). Recovery rate was calculated as $1-T_{recovery}/T_{sim}$ where the recovery time, $T_{recovery}$, was the number of years/generations it took for the metapopulation to reach five consecutive years ≥ pre-disturbance abundance. Recovery rate captures how quickly the aggregate metapopulation recovers from disturbance but doesn’t take into account whether any given local patches recover to their pre-disturbance capacity nor did it allow for any uncertainty around recovery criteria.

2. Patch occupancy - the mean number of patches with `>0.1` local carrying capacity after disturbance in the short-term (5 years), medium-term (10 years), and long-term (25 years). This value characterizes the expected risk of spatial contractions or local patch collapses, and reflects how interactions between spatial structure, disturbance, and dispersal shape source-sink dynamics and the ability to provide (or not) rescue effects and recover local patches.

3. The ratio of expected maximum surplus production (we term *MSY*) to true maximum surplus production summed across all patches from fitted stock-recruitment model to aggregate across metapopulation such that:  
\begin{align}
\Delta_{MSY}=\cfrac{\hat{MSY_M}}{\sum_{i=1}^{P} MSY_{i}}
\end{align}  
A value of 1.0 would indicate that the disturbed metapopulation can sustain itself against the same disturbance regime as the sum of each patch independently. In other words, was the metapopulation more than ($\Delta_{MSY}$>1.0), less than ($\Delta_{MSY}$<1.0), or equal to the sum of its parts ($\Delta_{MSY}$=1.0). We detail how *MSY* was estimated further below.

### Monitoring & management at aggregate-scale
While true metapopulation dynamics emerge from local patch dynamics and dispersal in S.1, natural resource managers often monitor and manage at the scale of the metapopulation. Hence, management at this scale inherently defines the stock-recruitment dynamics of the aggregate complex of patches (i.e., metapopulation) as:

\begin{align}
{K}_{t}=\cfrac{\hat{\alpha_t}{A}_{t-1}}{1+\cfrac{\hat{\alpha_t}-1}{\hat{\beta_t}}{A}_{i,t-1}}
\end{align}

where $\hat{\alpha_t}$ was the estimated compensation ratio averaged across the metapopulation at time *t* and $\hat{\beta_t}$ was the estimated carrying capacity of the entire metapopulation. Necessarily, these estimates emerge from monitoring data collected across all patches and are sensitive to the quality of the data and how local patches perform through time. For example, temporal shifts in productivity regimes may be masked if most of the data were sampled before the regime shift. To help surmount these issues, modern resource assessments use data weighting and penalties (i.e., priors) when fitting models to data.

In our assessment, we weighted recent years of sampling over more distant years such that:

```{r ,echo=FALSE,fig.hold=TRUE,fig.height=4,fig.width=4.5,fig.cap="Likelihood weighting for samples collected over time from current year of sampling.",fig.align="center"}
dataWeighting <- 0.1
curve(exp(dataWeighting*(-x))/max(exp(dataWeighting*(-x))),from=0,to=100,xlab="Years lagged",ylab="Likelihood weight")
```

This forward-weighting approach increased the sensitivity of the monitoring sub-model to detect demographic changes in the post-disturbance recovery regime. Data-weighting is increasingly being used in resource monitoring, although how weights are developed and applied to data is a case-by-case basis.

Furthermore, we used penalized normal likelihoods on both $\hat{\alpha_t}$ and $\hat{\beta_t}$ such that:

\begin{align}
\hat{\alpha_t} \sim N(\mu=\hat{\alpha_{t-1}},\sigma=3\hat{\alpha_{t-1}})
\end{align}

and

\begin{align}
\hat{\beta_t} \sim N(\mu=\hat{\beta_{t-1}},\sigma=3\hat{\beta_{t-1}})
\end{align}

where $\mu=\hat{\alpha_{t-1}}$ and $\mu=\hat{\beta_{t-1}}$ represents the best estimates from the previous assessment and the `3` in the $\sigma$ term represents a 300% coefficient of variation. We used these penalized likelihoods to fit the above aggregate stock-recruitment model with *lognormal* error to the metapopulation stock-recruit data collected at time *t*. We used the following function and fitted to the below $\theta$ parameters (termed `theta` in the function `optim()` using the `L-BFGS-B` optimizer with a lower bound on $\hat{\alpha}$ of `1.01` (i.e., constrained to be at least above replacement).

```{r assessment model}
SRfn <- function(theta,data,lastYr){
  a.hat <- theta[1]
  b.hat <- exp(theta[2])
  sd.hat <- exp(theta[3])
  rec.mean <- (a.hat*data$spawners)/(1+((a.hat-1)/b.hat)*data$spawners)
  # negative log likelihood on recruitment parameters
  nll <- -1*sum(dlnorm(data$recruits,meanlog=log(rec.mean),sdlog=sd.hat,log=TRUE)*data$weights,na.rm=TRUE)
  # penalized likelihood on estimated alpha
  penalty1 <- -dnorm(a.hat,lastYr$alphaLstYr,4*lastYr$alphaLstYr,log=TRUE)
  # penalized likelihood on estimated carrying capacity
  penalty2 <- -dnorm(b.hat,lastYr$metaKLstYr,4*lastYr$metaKLstYr,log=TRUE)
  jnll <- sum(c(nll,penalty1,penalty2),na.rm=TRUE)
  return(jnll)
}
```


This above function allows us to assess the bias in $\hat{\alpha_t}$, $\hat{\beta_t}$, and $\hat{K_t}$ compared to true $\bar{\alpha}$, $\bar{\beta}$, and ${K}_t$ across the metapopulation. This then allows us to see how much information management & monitoring programs were missing when they assess metapopulations at the aggregate (rather than local) scales.

### Finding maximum sustainable yield

Resource managers measure productivity with a variety of performance reference points [@Forrest2010]. One of the most widely used metrics, commonly called *Maximum Sustainable Yield* in fisheries and other harvest literature ($MSY$), relates to the largest loss the population can sustain over an indefinite period of time that maximizes its ability to replenish itself. Under density-dependent growth, individuals' growth, survival, and reproduction at low population densities are not constrained by limited resources, but overall production is low because there are few individuals. At high densities, limited resources increasingly constrain individual's reproductive success until the population reaches carrying capacity, and overall production drops to zero because per-capita success is low. However, at some intermediate densities, both per-capita and overall production is high, and population growth is at its maximum point due to the large number of reproducing individuals. At this point, there is the maximum surplus of individuals produced above replacement that can help to withstand disturbance or harvest regimes and contribute to future recovery, either through increasing local patch densities or by emigrating neighboring patches providing "rescue effects".

Under Beverton-Holt or Ricker density-dependent recuitment, however, there exists no analytical solution for calculating $MSY$. Therefore, we used numerical methods and a one dimensional root finder to iteratively search for the population mortality that maximized surplus production in the metapopulation. We term this mortality $F_{MSY}$ and can use this mortality value to calculate maximum surplus production $MSY$, the adult densities that produce $MSY$ (termed $N_{MSY}$), and the recruits that result from this (termed $R_{MSY}$).

```{r maximum sustainable yield}
# uniroot numerical search
yieldRoot<-function(alpha,beta,Fcur,model)
{
  Ucur <- 1-exp(-Fcur)
  if(model=="Beverton-Holt")
  {
    # population model is R ~ (CR * S)/(1+(CR-1)/K * S): reparameterized Beverton-Holt
    adults <- beta*exp(-Fcur)
    recruits <- (alpha*adults)/(1+((alpha-1)/beta)*adults)
    yield <- recruits-adults
  }
  if(model=="Ricker")
  {
    # population model is R ~ CR * S * e(-log(CR)/K * S): reparameterized Ricker
    adults <- beta*exp(-Fcur)
    recruits <- alpha*adults*exp((-log(alpha)/beta)*adults)
    yield <- recruits-adults
  }
  return(list(recruits=recruits,adults=adults,yield=yield))
}

# Return approximate gradient for integral
fun_yield <- function(Fcur,alpha,beta,delta,model)
{
  y1 <- yieldRoot(alpha=alpha,beta=beta,Fcur=Fcur-delta/2,model=model)$yield
  y2 <- yieldRoot(alpha=alpha,beta=beta,Fcur=Fcur+delta/2,model=model)$yield
  approx.gradient <- (y2-y1)/delta
  return(approx.gradient)
}

# uniroot search for optimal yield and Fmsy
findMSY <- function(alpha,beta,Npatches,model){
  F_msy <- NULL
  for(i in 1:Npatches){
    a_p <- alpha[i]
    b_p <- beta[i]
    F_msy[i] <- uniroot(fun_yield, interval=c(0,1),extendInt="yes",alpha=a_p,beta=b_p, delta=0.0001,model=model)$root 
  }
  MSY <- sapply(1:Npatches,function(x){yieldRoot(alpha=alpha[x],beta=beta[x],Fcur=F_msy[[x]][1],model=model)})
  return(list("F_msy"=F_msy,"MSY"=MSY))
}
```

## Scenarios

We tested all combinations of the following eight processes (below) and ran `100` iterations per scenario to estimate the mean for each of the above outcomes.

1. Homogenous and spatially variable recruitment compensation ratio across patches, i.e. intrinsic rate of population growth ($\alpha_i$).

2. Homogenous and spatially variable local carrying capacity across patches, i.e. asymptote of expected recruits at high adult densities ($\beta_i$)

3. Disturbances where a proportion of individuals removed from metapopulation (e.g., `0.90`) occurs.
    a. *uniform* - random individuals removed at equal vulnerability across all patches.
    b. *localized, even* - random individuals removed from randomly selected subset of patches (as long as the target individuals lost in the metapopulation can be achieved in that subset of patches)
    c. *localized, uneven* - total extirpation of randomly selected subset of patches (as long as the target individuals lost in the metapopulation can be achieved in that subset of patches)

4. Density-independent dispersal rates $\omega$ from 0 to 5% of individuals within a patch will disperse.

5. Topology of the spatial networks with linear, dendritic, star, and grid networks. Each network with $P=16$ and distance between patches $\bar{d}=1$.

6. Stochastic recruitment deviates from low, medium, high coefficient of variation on lognormal error. Generate stochasticity in time-dynamics via random recruitement deviates away from expected.

7. Temporal correlation in recruitment deviates from low, medium, high correlation (i.e., good year at time *t* begets good year at time *t+1*).

8. Spatial correlation in recruitment deviates among patches from low, medium, to high correlation (i.e., neighboring patches go up or down together).

### Example results

We demonstrate our metapopulation model with an example outcome for a linear network composed of `16` patches, a dispersal rate of `0.01` and a high enough dispersal cost such that individuals are only willing to move to their closest neighboring patches. This limits the strength of potential rescue effects. For this example, patches varied in their productivity and carrying capacity but will have deterministic population dynamics.

```{r example results1, echo=FALSE,fig.height=5.5,fig.width=6,fig.cap="Example iteration of spatial recovery regime of metapopulation with linear topology through time (top left) and space (top right). Recruitment dynamics before and 10 years after disturbance (bottom left). Relative bias in aggregate-scale estimates of carrying capacity, compensation ratio, and recruitment production in recovery phase (bottom right).",fig.align="center"}
seed <- 535
set.seed(seed)
linearSim <- metaPop(Npatches=16,networkType="linear",patchDistance=1,Nburnin=50,NyrsPost=100,omega=0.01,m=100,alpha=2,metaK=1600,cv=1e-6,DistScenario="uniform",magnitude_of_decline=0.9,lagTime=1,prodType="Beverton-Holt",rho.time=1e-5,rho.dist=1e5,compensationLag=25,dataWeighting=0.1,alphaVariable=TRUE,kVariable=TRUE,spatialPlots=TRUE)
```
\newpage
We can then contrast this with a different network shape, like a dendritic network. 

```{r example results2, echo=FALSE,fig.height=5.5,fig.width=6,fig.cap="Example iteration of spatial recovery regime of metapopulation with dendritic topology.",fig.align="center"}
seed <- 535
set.seed(seed)
dendriticSim <- metaPop(Npatches=16,networkType="dendritic",patchDistance=1,Nburnin=50,NyrsPost=100,omega=0.01,m=100,alpha=2,metaK=1600,cv=1e-6,DistScenario="uniform",magnitude_of_decline=0.9,lagTime=1,prodType="Beverton-Holt",rho.time=1e-5,rho.dist=1e5,compensationLag=25,dataWeighting=0.1,alphaVariable=TRUE,kVariable=TRUE,spatialPlots=TRUE)
```
\newpage
Now, let's add some stochasticity to recruitment and see how this affects the recovery regime.

```{r example results3, echo=FALSE,fig.height=5.5,fig.width=6,fig.cap="Example iteration of spatial recovery regime of stochastic metapopulation.",fig.align="center"}
seed <- 535
set.seed(seed)
dendriticSim2 <- metaPop(Npatches=16,networkType="dendritic",patchDistance=1,Nburnin=50,NyrsPost=100,omega=0.01,m=100,alpha=2,metaK=1600,cv=0.1,DistScenario="uniform",magnitude_of_decline=0.9,lagTime=1,prodType="Beverton-Holt",rho.time=1e-5,rho.dist=1e5,compensationLag=25,dataWeighting=0.1,alphaVariable=TRUE,kVariable=TRUE,spatialPlots=TRUE)
```
\newpage
Next, we can contrast with a disturbance regime where the disturbance is concentrated on local patches that can be completely extirpated (rather than the disturbance being applied proportionally across all patches e.g., a mixed-stock fishery).

```{r example results4, echo=FALSE,fig.height=5.5,fig.width=6,fig.cap="Example iteration of spatial recovery regime of stochastic metapopulation.",fig.align="center"}
seed <- 535
set.seed(seed)
dendriticSim3 <- metaPop(Npatches=16,networkType="dendritic",patchDistance=1,Nburnin=50,NyrsPost=100,omega=0.01,m=100,alpha=2,metaK=1600,cv=0.1,DistScenario="random_patch",magnitude_of_decline=0.9,lagTime=1,prodType="Beverton-Holt",rho.time=1e-5,rho.dist=1e5,compensationLag=25,dataWeighting=0.1,alphaVariable=TRUE,kVariable=TRUE,spatialPlots=TRUE)
```
\newpage
## General patterns

### Effects of disturbance regime
The strongest lever influencing recovery in our simulated metapopulations was, by far, the characteristics of the disturbance regime. Specifically, the degree to how locally concentrated the disturbance was on the set of patches was more influential than variable density dependence, dispersal rates, or network topology. This was surprising and not expected in our initial hypotheses. Localized disturbances increased the risk of spatial contraction, reduced recovery rates and aggregate compensation, and increased the risk of a long-term state shift. By altering aggregate compensation, localized disturbance reduced the surplus production of the metapopulation. In other words, through changes in source-sink dynamics, metapopulations under localized disturbance acted less than the sum of their parts – the more localized the impacts, the worse these effects. Uniform disturbances generally left the metapopulation dynamics unaffected with few ecological surprises. These above spatial and temporal recovery processes also appeared tied to one another such that changes to any of them had feedbacks with other recovery metrics.

```{r disturbance regime, echo=FALSE,fig.height=5,fig.width=5.5,fig.cap="Spatial and temporal recovery patterns along disturbance regimes across all scenarios.",fig.align="center"}
results <- readRDS("Simulations/results2022-05-04.rds")
scenarios <- readRDS("Simulations/scenarios2022-05-04.rds")
Nboots <- 100
Nlevels <- 11
model <- "Beverton-Holt"
# simulation parameters
Npatches <- 16
patchDist <- 1
Nburnin <- 50
NyrsPost <- 100
Nyears <- Nburnin+NyrsPost
compLag <- 25 # how many years to lag estimates of compensation
dataWeighting <- 0.1 # penalty to past years for data weighting
m <- 100 # distance decay function: penalty of 1 says about 60% of dispersing recruits move to neighbor patches. penalty of 2 says about 90% of dispersing recruits move to neighbor patches
# adult stock-juvenile recruitment traits
alpha <- 2
metaK <- 1600
# how big is the disturbance after Nburnin years?
magnitude_of_decline <- 0.9
# what is the lag time between recruits and spawners
lagTime <- 1

results$StateShift <- ((1-results$recovered)+(1-results$longOcc))/2
results$RecoveryRate <- 1-results$recovery/NyrsPost
results$collapsed <- 100*(1-results$recovered)
results$disturb_lab <- factor(results$disturbance,levels=levels(results$disturbance),labels=c("Uniform","Local, even","Local, uneven"))
mean_res <- aggregate(cbind(RecoveryRate,collapsed,longOcc,longMSY)~disturb_lab,data=results,FUN=mean)

dist_colours <- c("tomato","dodgerblue","orange")
transparency <- 0.6
plotColours <- ifelse(results$dispersal==-1,
                           adjustcolor(dist_colours[results$disturbance],1,offset=c(-0.35,-0.35,-0.35,0)),
                           adjustcolor(dist_colours[results$disturbance],1))

layout(matrix(1:4,nrow=2,ncol=2,byrow=TRUE))
par(mar=c(4,4,0.5,0.5))
plot(results$RecoveryRate,results$longOcc,pch=21,bg=plotColours,xlab=expression('Recovery rate (yr'^-1*')'),ylab="Relative patch occupancy (25 years)",cex.lab=0.7,cex.axis=0.85)

invisible(lapply(1:length(scenarios$disturbance),FUN=function(z){polygon(findHull(df=results[results$disturbance==scenarios$disturbance[z],],x="RecoveryRate",y="longOcc"),col=adjustcolor(dist_colours[z],transparency))}))
Corner_text("(a)", "topleft")
points(mean_res$RecoveryRate,mean_res$longOcc,pch=22,cex=2,bg=dist_colours)

plot(results$RecoveryRate,results$longMSY,pch=21,bg=plotColours,xlab=expression('Recovery rate (yr'^-1*')'),ylab="Relative surplus production (25 years)",cex.lab=0.7,cex.axis=0.85)
invisible(lapply(1:length(scenarios$disturbance),FUN=function(z){polygon(findHull(df=results[results$disturbance==scenarios$disturbance[z],],x="RecoveryRate",y="longMSY"),col=adjustcolor(dist_colours[z],transparency))}))
Corner_text("(b)", "topleft")
points(mean_res$RecoveryRate,mean_res$longMSY,pch=22,cex=2,bg=dist_colours)

plot(results$RecoveryRate,results$collapsed,pch=21,bg=plotColours,xlab=expression('Recovery rate (yr'^-1*')'),ylab="Rate of non-recovery (% of simulations)",cex.lab=0.7,cex.axis=0.85)
invisible(lapply(1:length(scenarios$disturbance),FUN=function(z){
  if(z<3){polygon(findHull(df=results[results$disturbance==scenarios$disturbance[z],],x="RecoveryRate",y="collapsed"),col=adjustcolor(dist_colours[z],transparency))}else{xMat <- unique(cbind(results[results$disturbance==scenarios$disturbance[z],"RecoveryRate"],results[results$disturbance==scenarios$disturbance[z],"collapsed"]))
  xSeq <- seq(min(xMat[,1]),max(xMat[,1]),by=0.1)
  polyMinMax <- cbind(c(xSeq,rev(xSeq)),c(sapply(xSeq,function(x){min(xMat[abs(xMat[which.min(abs(xMat[,1]-x)),1]-xMat[,1])<=0.025,2])}),sapply(rev(xSeq),function(x){max(xMat[abs(xMat[which.min(abs(xMat[,1]-x)),1]-xMat[,1])<=0.025,2])})))
  polygon(polyMinMax[,1],polyMinMax[,2],col=adjustcolor(dist_colours[z],transparency))}}))
Corner_text("(c)", "topleft")
points(mean_res$RecoveryRate,mean_res$collapsed,pch=22,cex=2,bg=dist_colours)

plot(results$longMSY,results$longOcc,pch=21,bg=plotColours,xlab="Relative surplus production (25 years)",ylab="Relative patch occupancy (25 years)",cex.lab=0.7,cex.axis=0.85)
invisible(lapply(1:length(scenarios$disturbance),FUN=function(z){polygon(findHull(df=results[results$disturbance==scenarios$disturbance[z],],x="longMSY",y="longOcc"),col=adjustcolor(dist_colours[z],transparency))}))
Corner_text("(d)", "topleft")
points(mean_res$longMSY,mean_res$longOcc,pch=22,cex=2,bg=dist_colours)

legend("bottomright",c("Uniform","Local, even","Local, uneven"),pch=22,pt.bg=dist_colours,bty="n",title="Disturbance regime",cex=0.8)
```
\newpage
### Role of network structure & dispersal

We now show some general patterns in how variable patch demographic rates, network structure, dispersal, disturbance, recruitment stochasticity, and spatio-temporal correlations variation affects metapopulation *recovery rates*, *maximum sustainable yield* (analagous to the maximum rate of loss the system can sustain), and *collapse rate* (i.e, the number of simulations where the metapopulation fails to recover), and *patch occupancy* (i.e., number of patches with local abundance <10% of pre-disturbance).

```{r recovery and dispersal and spatial network, echo=FALSE,fig.height=5,fig.width=5.5,fig.cap="Metapopulation recovery rates along gradients of network configuration, dispersal rates, and spatial distribution of disturbance. The shaded region describes the interquartile range across all scenarios.",fig.align="center"}
results <- readRDS("Simulations/results2022-05-04.rds")
scenarios <- readRDS("Simulations/scenarios2022-05-04.rds")
Nboots <- 100
Nlevels <- 11
model <- "Beverton-Holt"
# simulation parameters
Npatches <- 16
patchDist <- 1
Nburnin <- 50
NyrsPost <- 100
Nyears <- Nburnin+NyrsPost
compLag <- 25 # how many years to lag estimates of compensation
dataWeighting <- 0.1 # penalty to past years for data weighting
m <- 100 # distance decay function: penalty of 1 says about 60% of dispersing recruits move to neighbor patches. penalty of 2 says about 90% of dispersing recruits move to neighbor patches
# adult stock-juvenile recruitment traits
alpha <- 2
metaK <- 1600
# how big is the disturbance after Nburnin years?
magnitude_of_decline <- 0.9
# what is the lag time between recruits and spawners
lagTime <- 1

results$StateShift <- ((1-results$recovered)+(1-results$longOcc))/2
results$RecoveryRate <- 1-results$recovery/NyrsPost
results$collapsed <- 100*(1-results$recovered)

dist_colours <- c("tomato","dodgerblue","orange")
transparency <- 0.6
plotColours <- ifelse(results$dispersal==-1,
                      adjustcolor(dist_colours[results$disturbance],1,offset=c(-0.35,-0.35,-0.35,0)),
                      adjustcolor(dist_colours[results$disturbance],1))
matLayout <- matrix(0,nrow=16,ncol=16)
matLayout <- matrix(0,nrow=16,ncol=16)
matLayout[1:8,1:8] <- 1
matLayout[1:8,9:16] <- 2
matLayout[9:16,1:8] <- 3
matLayout[9:16,9:16] <- 4
matLayout[5:7,6:8] <- 5
matLayout[5:7,14:16] <- 6
matLayout[13:15,6:8] <- 7
matLayout[13:15,14:16] <- 8

layout(matLayout)
par(mar=c(4,4.5,0.5,0.5))
for(i in 1:length(scenarios$network))
{
  subResults <- results[results$network==scenarios$network[i],]
  plot(subResults$dispersal,subResults$RecoveryRate,col=0,lty=0,type="b",lwd=0,pch=0,ylab=expression('Recovery rate (yr'^-1*')'),xlab="Dispersal rate",ylim=1.0*range(c(0,results$RecoveryRate)),cex.lab=1.2)
  for(j in 1:length(scenarios$disturbance)){
    distResults <- subResults[subResults$disturbance==scenarios$disturbance[j],]
    #points(distResults$dispersal,distResults$recovery,bg=dist_colours[j],pch=21)
  }
  
  invisible(lapply(1:length(scenarios$disturbance),FUN=function(z){
    y_rng <- sapply(1:length(scenarios$dispersal),function(x){quantile(subResults$RecoveryRate[v_all.equal(subResults$dispersal,scenarios$dispersal[x]) & subResults$disturbance==scenarios$disturbance[z]],probs=c(0.25,0.75))});
    polygon(x=c(scenarios$dispersal,rev(scenarios$dispersal)),y=c(y_rng[1,],rev(y_rng[2,])),col=adjustcolor(dist_colours[z],transparency))}))
}
legend("right",c("Uniform","Local, even","Local, uneven"),pch=22,pt.bg=dist_colours,bty="n",title="Disturbance regime",cex=1.2)
add2plot()

```

Dispersal, landscape structure, and local density-dependence also affected metapopulation recovery patterns in three key ways, though to a lesser extent. First, recovery rates increased with increased dispersal. However, this effect was nonlinear with diminishing benefits of dispersal occurring at ~1-3%, depending on spatial structure and disturbance. Second, more linearized networks had slower recovery times than more connected networks suggesting that rescue effects take some time to cascade through the entire network of patches; but this interacted with the disturbance regime as only local, extirpation exhibited this change in any substantial manner. Last, diversity in local patch compensation and carrying capacities tended to slow metapopulation recoveries - this effect interacted with other factors like stochasticity.

```{r recovery with patch variation,echo=FALSE,warning = FALSE, message = FALSE,fig.height=4.5,fig.width=6,fig.cap="Effects of variable local patch productivities on metapopulation recovery across all scenarios.",fig.align="center"}
results <- readRDS("Simulations/results2022-05-04.rds")
scenarios <- readRDS("Simulations/scenarios2022-05-04.rds")
Nboots <- 100
Nlevels <- 11
model <- "Beverton-Holt"
# simulation parameters
Npatches <- 16
patchDist <- 1
Nburnin <- 50
NyrsPost <- 100
Nyears <- Nburnin+NyrsPost
compLag <- 25 # how many years to lag estimates of compensation
dataWeighting <- 0.1 # penalty to past years for data weighting
m <- 100 # distance decay function: penalty of 1 says about 60% of dispersing recruits move to neighbor patches. penalty of 2 says about 90% of dispersing recruits move to neighbor patches
# adult stock-juvenile recruitment traits
alpha <- 2
metaK <- 1600
# how big is the disturbance after Nburnin years?
magnitude_of_decline <- 0.9
# what is the lag time between recruits and spawners
lagTime <- 1

results$StateShift <- ((1-results$recovered)+(1-results$longOcc))/2
results$RecoveryRate <- 1-results$recovery/NyrsPost
results$collapsed <- 1-results$recovered

dist_colours <- c("tomato","dodgerblue","orange")
transparency <- 0.6
plotColours <- ifelse(results$dispersal==-1,
                           adjustcolor(dist_colours[results$disturbance],1,offset=c(-0.35,-0.35,-0.35,0)),
                           adjustcolor(dist_colours[results$disturbance],1))
# http://www.sthda.com/english/wiki/ggplot2-violin-plot-quick-start-guide-r-software-and-data-visualization
results$patchScen <- paste(results$alpha,"\u03B1","\n",results$beta,"\u03B2")
results$stochasticity <- as.character(results$stochastic)
p <- ggplot(data=results, aes(x=patchScen, y=RecoveryRate, fill=stochasticity))+ 
  geom_violin(trim=FALSE,scale = "width")+
  facet_wrap(~stochasticity)+
  geom_boxplot(width=0.1,colour="grey90",outlier.shape=NA,fill="grey50")+
  scale_fill_brewer(palette="Dark2") +
  labs(x="Patch variation",y=expression('Recovery rate (yr'^-1*')'),fill="Stochasticity") +
  theme_minimal() +
  theme(legend.position="top",strip.text.x = element_blank())
p


```
\newpage
### Surprising ecological outcomes

Metapopulation recovery regimes emerged from a complex interplay of density-dependent productivity (shown in Figure 6 of the main text), network structure (shown here), dispersal, and disturbance regimes. Overall, clustering analyses of our model results found evidence for six common outcomes: (1) resilient recovery – metapopulation recovery <10 years, (2) slow recovery – metapopulation recovery >10 years and no other surprise, (3) lost capacity – long-term maximum surplus production <50% before disturbance, (4) hidden collapses – metapopulation recovered (or was recovering) but 50% of patches remain unoccupied, (5) spatial contraction – >25% of patches remain unoccupied and (6) critical risk – metapopulation abundance remains <10% of pre-disturbance. Resilient recovery regimes were most common when disturbance was evenly applied across the network and local patches were identical. Any localized disturbances could create ecological surprises, and the frequency of these surprises were often exacerbated when patches were diverse. Localized, even disturbances tended to reduce recovery by 50% compared to even disturbances (from 16 years to 24 years on average). The riskiest recovery outcomes emerged when disturbance was localized and allowed for extirpation. In these scenarios, recovery was slowed by >100% (from 16 years to >32 years on average), surplus production was often reduced by >50%, long-term patch occupancy was reduced by >35%. Last, note that linear networks tended to have higher risks for long-term spatial contractions.

```{r cluster results, echo=FALSE,warning = FALSE, message = FALSE,fig.height=5,fig.width=8,fig.cap="Interplay between network structure, disturbance, and dispersal can lead to suprising recovery outcomes.",fig.align="center"}
library(ggalluvial)
surprises <- readRDS(file="Figures/gg_clustering_outcomes.rds")
gradColour <- colorRampPalette(rev(c("black","#bd0026","tomato","#fdae61","dodgerblue","forestgreen")))
n_id <- sum(surprises$surprise_logic)
n_resilient <- sum(surprises$surprise_logic[surprises$cluster_surprises=='Resilient'])
surprises$surprise_index <- ifelse(surprises$cluster_surprises=="Resilient","Expected","Surprised")
n_outcomes <- (sapply(unique(surprises$cluster_surprises),function(x){sum(surprises$surprise_logic[surprises$cluster_surprises==x])}))
n_cumul <- c(0,cumsum(n_outcomes))
n_cumul <- sapply(2:length(n_cumul),function(x){median(c(n_cumul[x],n_cumul[x-1]))})
margins <- c(0.1,0.1,0.1,0.1)
p1 <- ggplot(surprises,aes(y = surprise_logic,axis1 = network_lab, axis2 = dispersal_range,axis3=disturb_lab,axis4=cluster_surprises)) +
      geom_alluvium(aes(fill = cluster_surprises),width = 1/6,reverse=FALSE) +
      #guides(fill = FALSE) +
      geom_stratum(width = 1/6,fill="grey",color="white", reverse = FALSE) +
      geom_text(stat = "stratum",size=2.5, aes(label = after_stat(stratum)), reverse = FALSE) +
      scale_x_discrete(limits = c("Network structure", "Dispersal","Disturbance","Outcome"),expand=c(0.075,0.075)) +
      scale_y_continuous(breaks = seq(0,n_id,length.out=5),label = scales::percent_format(scale = 100 / n_id),sec.axis=sec_axis(~./1,breaks = n_cumul,label = paste(round(100*n_outcomes/n_id),"%",sep=""))) +
      scale_fill_manual(values=gradColour(n=length(unique(surprises$cluster_surprises)))) +
      #scale_fill_brewer(type="div",palette="RdYlBu",direction=-1) +
      theme_minimal() +
      ylab("Frequency of strata (% of simulations)") +
      coord_cartesian(clip = "off") +
      theme(legend.position="bottom",strip.text.x=element_blank(),plot.margin=unit(margins,"line"),text=element_text(size=7),axis.text=element_text(size=7),axis.title=element_text(size=9),legend.text = element_text(size=7)) +
      ggtitle("Ecological surprises in metapopulations")
p1

```

## References
